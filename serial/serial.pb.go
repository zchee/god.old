// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: serial/serial.proto

/*
	Package serial is a generated protocol buffer package.

	It is generated from these files:
		serial/serial.proto

	It has these top-level messages:
		Location
		Options
		Peers
		ReferrersInitial
		ReferrersPackage
		Ref
		Definition
		Callees
		Callee
		Callers
		Caller
		CallStack
		FreeVars
		FreeVar
		Implements
		ImplementsType
		SyntaxNode
		What
		PointsToLabel
		PointsTo
		DescribeValue
		DescribeMethod
		DescribeType
		DescribeMember
		DescribePackage
		Describe
		WhichErrs
		WhichErrsType
		Request
		Response
*/
package serial

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Location is the location of current cursor.
type Location struct {
	Filename string   `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	Line     int64    `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
	Col      int64    `protobuf:"varint,3,opt,name=col,proto3" json:"col,omitempty"`
	Pos      string   `protobuf:"bytes,4,opt,name=pos,proto3" json:"pos,omitempty"`
	Options  *Options `protobuf:"bytes,5,opt,name=options" json:"options,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{0} }

type Options struct {
	Scope string `protobuf:"bytes,1,opt,name=Scope,proto3" json:"Scope,omitempty"`
}

func (m *Options) Reset()                    { *m = Options{} }
func (m *Options) String() string            { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()               {}
func (*Options) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{1} }

// Peers is the result of a 'peers' query.
// If Allocs is empty, the selected channel can't point to anything.
type Peers struct {
	Pos      string   `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Type     string   `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Allocs   []string `protobuf:"bytes,3,rep,name=Allocs" json:"Allocs,omitempty"`
	Sends    []string `protobuf:"bytes,4,rep,name=Sends" json:"Sends,omitempty"`
	Receives []string `protobuf:"bytes,5,rep,name=Receives" json:"Receives,omitempty"`
	Closes   []string `protobuf:"bytes,6,rep,name=Closes" json:"Closes,omitempty"`
}

func (m *Peers) Reset()                    { *m = Peers{} }
func (m *Peers) String() string            { return proto.CompactTextString(m) }
func (*Peers) ProtoMessage()               {}
func (*Peers) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{2} }

// A "referrers" query emits a ReferrersInitial object followed by zero or
// more ReferrersPackage objects, one per package that contains a reference.
type ReferrersInitial struct {
	ObjPos string `protobuf:"bytes,1,opt,name=ObjPos,proto3" json:"ObjPos,omitempty"`
	Desc   string `protobuf:"bytes,2,opt,name=Desc,proto3" json:"Desc,omitempty"`
}

func (m *ReferrersInitial) Reset()                    { *m = ReferrersInitial{} }
func (m *ReferrersInitial) String() string            { return proto.CompactTextString(m) }
func (*ReferrersInitial) ProtoMessage()               {}
func (*ReferrersInitial) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{3} }

type ReferrersPackage struct {
	Package string `protobuf:"bytes,1,opt,name=Package,proto3" json:"Package,omitempty"`
	Refs    []Ref  `protobuf:"bytes,2,rep,name=Refs" json:"Refs"`
}

func (m *ReferrersPackage) Reset()                    { *m = ReferrersPackage{} }
func (m *ReferrersPackage) String() string            { return proto.CompactTextString(m) }
func (*ReferrersPackage) ProtoMessage()               {}
func (*ReferrersPackage) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{4} }

type Ref struct {
	Pos  string `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Text string `protobuf:"bytes,2,opt,name=Text,proto3" json:"Text,omitempty"`
}

func (m *Ref) Reset()                    { *m = Ref{} }
func (m *Ref) String() string            { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()               {}
func (*Ref) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{5} }

// Definition is the result of a 'definition' query.
type Definition struct {
	ObjPos string `protobuf:"bytes,1,opt,name=ObjPos,proto3" json:"ObjPos,omitempty"`
	Desc   string `protobuf:"bytes,2,opt,name=Desc,proto3" json:"Desc,omitempty"`
}

func (m *Definition) Reset()                    { *m = Definition{} }
func (m *Definition) String() string            { return proto.CompactTextString(m) }
func (*Definition) ProtoMessage()               {}
func (*Definition) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{6} }

// Callees is the result of a 'callees' query.
type Callees struct {
	Pos     string    `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Desc    string    `protobuf:"bytes,2,opt,name=Desc,proto3" json:"Desc,omitempty"`
	Callees []*Callee `protobuf:"bytes,3,rep,name=Callees" json:"Callees,omitempty"`
}

func (m *Callees) Reset()                    { *m = Callees{} }
func (m *Callees) String() string            { return proto.CompactTextString(m) }
func (*Callees) ProtoMessage()               {}
func (*Callees) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{7} }

// Callees is nonempty unless the call was a dynamic call on a
// provably nil func or interface value.
type Callee struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Pos  string `protobuf:"bytes,2,opt,name=Pos,proto3" json:"Pos,omitempty"`
}

func (m *Callee) Reset()                    { *m = Callee{} }
func (m *Callee) String() string            { return proto.CompactTextString(m) }
func (*Callee) ProtoMessage()               {}
func (*Callee) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{8} }

// Callers is slice of Caller.
type Callers struct {
	Callers []*Caller `protobuf:"bytes,1,rep,name=Callers" json:"Callers,omitempty"`
}

func (m *Callers) Reset()                    { *m = Callers{} }
func (m *Callers) String() string            { return proto.CompactTextString(m) }
func (*Callers) ProtoMessage()               {}
func (*Callers) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{9} }

// Caller is one element of the slice returned by a 'callers' query.
// (Callstack also contains a similar slice.)
//
// The root of the callgraph has an unspecified "Caller" string.
type Caller struct {
	Pos    string `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Desc   string `protobuf:"bytes,2,opt,name=Desc,proto3" json:"Desc,omitempty"`
	Caller string `protobuf:"bytes,3,opt,name=Caller,proto3" json:"Caller,omitempty"`
}

func (m *Caller) Reset()                    { *m = Caller{} }
func (m *Caller) String() string            { return proto.CompactTextString(m) }
func (*Caller) ProtoMessage()               {}
func (*Caller) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{10} }

// CallStack is the result of a 'callstack' query.
// It indicates an arbitrary path from the root of the callgraph to
// the query function.
//
// If the Callers slice is empty, the function was unreachable in this
// analysis scope.
type CallStack struct {
	Pos     string   `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Target  string   `protobuf:"bytes,2,opt,name=Target,proto3" json:"Target,omitempty"`
	Callers []Caller `protobuf:"bytes,3,rep,name=Callers" json:"Callers"`
}

func (m *CallStack) Reset()                    { *m = CallStack{} }
func (m *CallStack) String() string            { return proto.CompactTextString(m) }
func (*CallStack) ProtoMessage()               {}
func (*CallStack) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{11} }

// FreeVars is the slice of FreeVar.
type FreeVars struct {
	FreeVar []*FreeVar `protobuf:"bytes,1,rep,name=FreeVar" json:"FreeVar,omitempty"`
}

func (m *FreeVars) Reset()                    { *m = FreeVars{} }
func (m *FreeVars) String() string            { return proto.CompactTextString(m) }
func (*FreeVars) ProtoMessage()               {}
func (*FreeVars) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{12} }

// FreeVar is one element of the slice returned by a 'freevars'
// query.  Each one identifies an expression referencing a local
// identifier defined outside the selected region.
type FreeVar struct {
	Pos  string `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Kind string `protobuf:"bytes,2,opt,name=Kind,proto3" json:"Kind,omitempty"`
	Ref  string `protobuf:"bytes,3,opt,name=Ref,proto3" json:"Ref,omitempty"`
	Type string `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *FreeVar) Reset()                    { *m = FreeVar{} }
func (m *FreeVar) String() string            { return proto.CompactTextString(m) }
func (*FreeVar) ProtoMessage()               {}
func (*FreeVar) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{13} }

// Implements contains the result of an 'implements' query.
// It describes the queried type, the set of named non-empty interface
// types to which it is assignable, and the set of named/*named types
// (concrete or non-empty interface) which may be assigned to it.
//
type Implements struct {
	T                 *ImplementsType  `protobuf:"bytes,1,opt,name=T" json:"T,omitempty"`
	AssignableTo      []ImplementsType `protobuf:"bytes,2,rep,name=AssignableTo" json:"AssignableTo"`
	AssignableFrom    []ImplementsType `protobuf:"bytes,3,rep,name=AssignableFrom" json:"AssignableFrom"`
	AssignableFromPtr []ImplementsType `protobuf:"bytes,4,rep,name=AssignableFromPtr" json:"AssignableFromPtr"`
	// The following fields are set only if the query was a method.
	// Assignable{To,From,FromPtr}Method[i] is the corresponding
	// method of type Assignable{To,From,FromPtr}[i], or blank
	// {"",""} if that type lacks the method.
	Method                  *DescribeMethod  `protobuf:"bytes,5,opt,name=Method" json:"Method,omitempty"`
	AssignableToMethod      []DescribeMethod `protobuf:"bytes,6,rep,name=AssignableToMethod" json:"AssignableToMethod"`
	AssignableFromMethod    []DescribeMethod `protobuf:"bytes,7,rep,name=AssignableFromMethod" json:"AssignableFromMethod"`
	AssignableFromPtrMethod []DescribeMethod `protobuf:"bytes,8,rep,name=AssignableFromPtrMethod" json:"AssignableFromPtrMethod"`
}

func (m *Implements) Reset()                    { *m = Implements{} }
func (m *Implements) String() string            { return proto.CompactTextString(m) }
func (*Implements) ProtoMessage()               {}
func (*Implements) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{14} }

// ImplementsType describes a single type as part of an 'implements' query.
type ImplementsType struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Pos  string `protobuf:"bytes,2,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Kind string `protobuf:"bytes,3,opt,name=Kind,proto3" json:"Kind,omitempty"`
}

func (m *ImplementsType) Reset()                    { *m = ImplementsType{} }
func (m *ImplementsType) String() string            { return proto.CompactTextString(m) }
func (*ImplementsType) ProtoMessage()               {}
func (*ImplementsType) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{15} }

// SyntaxNode is one element of a stack of enclosing syntax nodes in
// a "what" query.
type SyntaxNode struct {
	Description string `protobuf:"bytes,1,opt,name=Description,proto3" json:"Description,omitempty"`
	Start       int32  `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End         int32  `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
}

func (m *SyntaxNode) Reset()                    { *m = SyntaxNode{} }
func (m *SyntaxNode) String() string            { return proto.CompactTextString(m) }
func (*SyntaxNode) ProtoMessage()               {}
func (*SyntaxNode) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{16} }

// What is the result of the "what" query, which quickly identifies
// the selection, parsing only a single file.  It is intended for use
// in low-latency GUIs.
type What struct {
	Enclosing  []SyntaxNode `protobuf:"bytes,1,rep,name=Enclosing" json:"Enclosing"`
	Modes      []string     `protobuf:"bytes,2,rep,name=Modes" json:"Modes,omitempty"`
	SrcDir     string       `protobuf:"bytes,3,opt,name=SrcDir,proto3" json:"SrcDir,omitempty"`
	ImportPath string       `protobuf:"bytes,4,opt,name=ImportPath,proto3" json:"ImportPath,omitempty"`
	Object     string       `protobuf:"bytes,5,opt,name=Object,proto3" json:"Object,omitempty"`
	SameIDs    []string     `protobuf:"bytes,6,rep,name=SameIDs" json:"SameIDs,omitempty"`
}

func (m *What) Reset()                    { *m = What{} }
func (m *What) String() string            { return proto.CompactTextString(m) }
func (*What) ProtoMessage()               {}
func (*What) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{17} }

// PointsToLabel describes a pointer analysis label.
//
// A "label" is an object that may be pointed to by a pointer, map,
// channel, 'func', slice or interface.  Labels include:
//    - functions
//    - globals
//    - arrays created by literals (e.g. []byte("foo")) and conversions
//    ([]byte(s))
//    - stack- and heap-allocated variables (including composite literals)
//    - arrays allocated by append()
//    - channels, maps and arrays created by make()
//    - and their subelements, e.g. "alloc.y[*].z"
//
type PointsToLabel struct {
	Pos  string `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Desc string `protobuf:"bytes,2,opt,name=Desc,proto3" json:"Desc,omitempty"`
}

func (m *PointsToLabel) Reset()                    { *m = PointsToLabel{} }
func (m *PointsToLabel) String() string            { return proto.CompactTextString(m) }
func (*PointsToLabel) ProtoMessage()               {}
func (*PointsToLabel) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{18} }

// PointsTo is one element of the result of a 'pointsto' query on an
// expression.  It describes a single pointer: its type and the set of
// "labels" it points to.
//
// If the pointer is of interface type, it will have one PTS entry
// describing each concrete type that it may contain.  For each
// concrete type that is a pointer, the PTS entry describes the labels
// it may point to.  The same is true for reflect.Values, except the
// dynamic types needn't be concrete.
//
type PointsTo struct {
	Type    string          `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	NamePos string          `protobuf:"bytes,2,opt,name=NamePos,proto3" json:"NamePos,omitempty"`
	Labels  []PointsToLabel `protobuf:"bytes,3,rep,name=Labels" json:"Labels"`
}

func (m *PointsTo) Reset()                    { *m = PointsTo{} }
func (m *PointsTo) String() string            { return proto.CompactTextString(m) }
func (*PointsTo) ProtoMessage()               {}
func (*PointsTo) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{19} }

// DescribeValue is the additional result of a 'describe' query
// if the selection indicates a value or expression.
type DescribeValue struct {
	Type   string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	ObjPos string `protobuf:"bytes,3,opt,name=ObjPos,proto3" json:"ObjPos,omitempty"`
}

func (m *DescribeValue) Reset()                    { *m = DescribeValue{} }
func (m *DescribeValue) String() string            { return proto.CompactTextString(m) }
func (*DescribeValue) ProtoMessage()               {}
func (*DescribeValue) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{20} }

type DescribeMethod struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Pos  string `protobuf:"bytes,3,opt,name=Pos,proto3" json:"Pos,omitempty"`
}

func (m *DescribeMethod) Reset()                    { *m = DescribeMethod{} }
func (m *DescribeMethod) String() string            { return proto.CompactTextString(m) }
func (*DescribeMethod) ProtoMessage()               {}
func (*DescribeMethod) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{21} }

// DescribeType is the additional result of a 'describe' query
// if the selection indicates a type.
type DescribeType struct {
	Type    string           `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	NamePos string           `protobuf:"bytes,2,opt,name=NamePos,proto3" json:"NamePos,omitempty"`
	NameDef string           `protobuf:"bytes,3,opt,name=NameDef,proto3" json:"NameDef,omitempty"`
	Methods []DescribeMethod `protobuf:"bytes,4,rep,name=Methods" json:"Methods"`
}

func (m *DescribeType) Reset()                    { *m = DescribeType{} }
func (m *DescribeType) String() string            { return proto.CompactTextString(m) }
func (*DescribeType) ProtoMessage()               {}
func (*DescribeType) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{22} }

type DescribeMember struct {
	Name    string           `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type    string           `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Value   string           `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
	Pos     string           `protobuf:"bytes,4,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Kind    string           `protobuf:"bytes,5,opt,name=Kind,proto3" json:"Kind,omitempty"`
	Methods []DescribeMethod `protobuf:"bytes,6,rep,name=Methods" json:"Methods"`
}

func (m *DescribeMember) Reset()                    { *m = DescribeMember{} }
func (m *DescribeMember) String() string            { return proto.CompactTextString(m) }
func (*DescribeMember) ProtoMessage()               {}
func (*DescribeMember) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{23} }

// DescribePackage is the additional result of a 'describe' if
// the selection indicates a package.
type DescribePackage struct {
	Path    string            `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Members []*DescribeMember `protobuf:"bytes,2,rep,name=Members" json:"Members,omitempty"`
}

func (m *DescribePackage) Reset()                    { *m = DescribePackage{} }
func (m *DescribePackage) String() string            { return proto.CompactTextString(m) }
func (*DescribePackage) ProtoMessage()               {}
func (*DescribePackage) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{24} }

// Describe is the result of a 'describe' query.
// It may contain an element describing the selected semantic entity
// in detail.
type Describe struct {
	Desc   string `protobuf:"bytes,1,opt,name=Desc,proto3" json:"Desc,omitempty"`
	Pos    string `protobuf:"bytes,2,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Detail string `protobuf:"bytes,3,opt,name=Detail,proto3" json:"Detail,omitempty"`
	// At most one of the following fields is populated:
	// the one specified by 'detail'.
	Package *DescribePackage `protobuf:"bytes,4,opt,name=Package" json:"Package,omitempty"`
	Type    *DescribeType    `protobuf:"bytes,5,opt,name=Type" json:"Type,omitempty"`
	Value   *DescribeValue   `protobuf:"bytes,6,opt,name=Value" json:"Value,omitempty"`
}

func (m *Describe) Reset()                    { *m = Describe{} }
func (m *Describe) String() string            { return proto.CompactTextString(m) }
func (*Describe) ProtoMessage()               {}
func (*Describe) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{25} }

// A WhichErrs is the result of a 'whicherrs' query.
// It contains the position of the queried error and the possible globals,
// constants, and types it may point to.
type WhichErrs struct {
	ErrPos    string          `protobuf:"bytes,1,opt,name=ErrPos,proto3" json:"ErrPos,omitempty"`
	Globals   []string        `protobuf:"bytes,2,rep,name=Globals" json:"Globals,omitempty"`
	Constants string          `protobuf:"bytes,3,opt,name=Constants,proto3" json:"Constants,omitempty"`
	Types     []WhichErrsType `protobuf:"bytes,4,rep,name=Types" json:"Types"`
}

func (m *WhichErrs) Reset()                    { *m = WhichErrs{} }
func (m *WhichErrs) String() string            { return proto.CompactTextString(m) }
func (*WhichErrs) ProtoMessage()               {}
func (*WhichErrs) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{26} }

type WhichErrsType struct {
	Type     string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Position string `protobuf:"bytes,2,opt,name=Position,proto3" json:"Position,omitempty"`
}

func (m *WhichErrsType) Reset()                    { *m = WhichErrsType{} }
func (m *WhichErrsType) String() string            { return proto.CompactTextString(m) }
func (*WhichErrsType) ProtoMessage()               {}
func (*WhichErrsType) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{27} }

type Request struct {
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{28} }

type Response struct {
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorSerial, []int{29} }

func init() {
	proto.RegisterType((*Location)(nil), "serial.Location")
	proto.RegisterType((*Options)(nil), "serial.Options")
	proto.RegisterType((*Peers)(nil), "serial.Peers")
	proto.RegisterType((*ReferrersInitial)(nil), "serial.ReferrersInitial")
	proto.RegisterType((*ReferrersPackage)(nil), "serial.ReferrersPackage")
	proto.RegisterType((*Ref)(nil), "serial.Ref")
	proto.RegisterType((*Definition)(nil), "serial.Definition")
	proto.RegisterType((*Callees)(nil), "serial.Callees")
	proto.RegisterType((*Callee)(nil), "serial.Callee")
	proto.RegisterType((*Callers)(nil), "serial.Callers")
	proto.RegisterType((*Caller)(nil), "serial.Caller")
	proto.RegisterType((*CallStack)(nil), "serial.CallStack")
	proto.RegisterType((*FreeVars)(nil), "serial.FreeVars")
	proto.RegisterType((*FreeVar)(nil), "serial.FreeVar")
	proto.RegisterType((*Implements)(nil), "serial.Implements")
	proto.RegisterType((*ImplementsType)(nil), "serial.ImplementsType")
	proto.RegisterType((*SyntaxNode)(nil), "serial.SyntaxNode")
	proto.RegisterType((*What)(nil), "serial.What")
	proto.RegisterType((*PointsToLabel)(nil), "serial.PointsToLabel")
	proto.RegisterType((*PointsTo)(nil), "serial.PointsTo")
	proto.RegisterType((*DescribeValue)(nil), "serial.DescribeValue")
	proto.RegisterType((*DescribeMethod)(nil), "serial.DescribeMethod")
	proto.RegisterType((*DescribeType)(nil), "serial.DescribeType")
	proto.RegisterType((*DescribeMember)(nil), "serial.DescribeMember")
	proto.RegisterType((*DescribePackage)(nil), "serial.DescribePackage")
	proto.RegisterType((*Describe)(nil), "serial.Describe")
	proto.RegisterType((*WhichErrs)(nil), "serial.WhichErrs")
	proto.RegisterType((*WhichErrsType)(nil), "serial.WhichErrsType")
	proto.RegisterType((*Request)(nil), "serial.Request")
	proto.RegisterType((*Response)(nil), "serial.Response")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for God service

type GodClient interface {
	Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	GetCallees(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Callees, error)
	GetCallers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Callers, error)
	GetCallStack(ctx context.Context, in *Location, opts ...grpc.CallOption) (*CallStack, error)
	GetDefinition(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Definition, error)
	GetDescribe(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Describe, error)
	GetFreeVar(ctx context.Context, in *Location, opts ...grpc.CallOption) (*FreeVars, error)
	GetImplements(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Implements, error)
	GetPeers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Peers, error)
	GetPointsTo(ctx context.Context, in *Location, opts ...grpc.CallOption) (*PointsTo, error)
	GetReferrers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*ReferrersPackage, error)
	GetWhat(ctx context.Context, in *Location, opts ...grpc.CallOption) (*What, error)
	GetWhichErrs(ctx context.Context, in *Location, opts ...grpc.CallOption) (*WhichErrs, error)
}

type godClient struct {
	cc *grpc.ClientConn
}

func NewGodClient(cc *grpc.ClientConn) GodClient {
	return &godClient{cc}
}

func (c *godClient) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/serial.God/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetCallees(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Callees, error) {
	out := new(Callees)
	err := grpc.Invoke(ctx, "/serial.God/GetCallees", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetCallers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Callers, error) {
	out := new(Callers)
	err := grpc.Invoke(ctx, "/serial.God/GetCallers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetCallStack(ctx context.Context, in *Location, opts ...grpc.CallOption) (*CallStack, error) {
	out := new(CallStack)
	err := grpc.Invoke(ctx, "/serial.God/GetCallStack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetDefinition(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Definition, error) {
	out := new(Definition)
	err := grpc.Invoke(ctx, "/serial.God/GetDefinition", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetDescribe(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Describe, error) {
	out := new(Describe)
	err := grpc.Invoke(ctx, "/serial.God/GetDescribe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetFreeVar(ctx context.Context, in *Location, opts ...grpc.CallOption) (*FreeVars, error) {
	out := new(FreeVars)
	err := grpc.Invoke(ctx, "/serial.God/GetFreeVar", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetImplements(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Implements, error) {
	out := new(Implements)
	err := grpc.Invoke(ctx, "/serial.God/GetImplements", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetPeers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*Peers, error) {
	out := new(Peers)
	err := grpc.Invoke(ctx, "/serial.God/GetPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetPointsTo(ctx context.Context, in *Location, opts ...grpc.CallOption) (*PointsTo, error) {
	out := new(PointsTo)
	err := grpc.Invoke(ctx, "/serial.God/GetPointsTo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetReferrers(ctx context.Context, in *Location, opts ...grpc.CallOption) (*ReferrersPackage, error) {
	out := new(ReferrersPackage)
	err := grpc.Invoke(ctx, "/serial.God/GetReferrers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetWhat(ctx context.Context, in *Location, opts ...grpc.CallOption) (*What, error) {
	out := new(What)
	err := grpc.Invoke(ctx, "/serial.God/GetWhat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *godClient) GetWhichErrs(ctx context.Context, in *Location, opts ...grpc.CallOption) (*WhichErrs, error) {
	out := new(WhichErrs)
	err := grpc.Invoke(ctx, "/serial.God/GetWhichErrs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for God service

type GodServer interface {
	Ping(context.Context, *Request) (*Response, error)
	GetCallees(context.Context, *Location) (*Callees, error)
	GetCallers(context.Context, *Location) (*Callers, error)
	GetCallStack(context.Context, *Location) (*CallStack, error)
	GetDefinition(context.Context, *Location) (*Definition, error)
	GetDescribe(context.Context, *Location) (*Describe, error)
	GetFreeVar(context.Context, *Location) (*FreeVars, error)
	GetImplements(context.Context, *Location) (*Implements, error)
	GetPeers(context.Context, *Location) (*Peers, error)
	GetPointsTo(context.Context, *Location) (*PointsTo, error)
	GetReferrers(context.Context, *Location) (*ReferrersPackage, error)
	GetWhat(context.Context, *Location) (*What, error)
	GetWhichErrs(context.Context, *Location) (*WhichErrs, error)
}

func RegisterGodServer(s *grpc.Server, srv GodServer) {
	s.RegisterService(&_God_serviceDesc, srv)
}

func _God_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).Ping(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetCallees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetCallees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetCallees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetCallees(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetCallers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetCallers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetCallers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetCallers(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetCallStack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetCallStack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetCallStack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetCallStack(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetDefinition(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetDescribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetDescribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetDescribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetDescribe(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetFreeVar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetFreeVar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetFreeVar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetFreeVar(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetImplements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetImplements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetImplements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetImplements(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetPeers(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetPointsTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetPointsTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetPointsTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetPointsTo(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetReferrers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetReferrers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetReferrers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetReferrers(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetWhat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetWhat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetWhat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetWhat(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

func _God_GetWhichErrs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Location)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GodServer).GetWhichErrs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/serial.God/GetWhichErrs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GodServer).GetWhichErrs(ctx, req.(*Location))
	}
	return interceptor(ctx, in, info, handler)
}

var _God_serviceDesc = grpc.ServiceDesc{
	ServiceName: "serial.God",
	HandlerType: (*GodServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _God_Ping_Handler,
		},
		{
			MethodName: "GetCallees",
			Handler:    _God_GetCallees_Handler,
		},
		{
			MethodName: "GetCallers",
			Handler:    _God_GetCallers_Handler,
		},
		{
			MethodName: "GetCallStack",
			Handler:    _God_GetCallStack_Handler,
		},
		{
			MethodName: "GetDefinition",
			Handler:    _God_GetDefinition_Handler,
		},
		{
			MethodName: "GetDescribe",
			Handler:    _God_GetDescribe_Handler,
		},
		{
			MethodName: "GetFreeVar",
			Handler:    _God_GetFreeVar_Handler,
		},
		{
			MethodName: "GetImplements",
			Handler:    _God_GetImplements_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _God_GetPeers_Handler,
		},
		{
			MethodName: "GetPointsTo",
			Handler:    _God_GetPointsTo_Handler,
		},
		{
			MethodName: "GetReferrers",
			Handler:    _God_GetReferrers_Handler,
		},
		{
			MethodName: "GetWhat",
			Handler:    _God_GetWhat_Handler,
		},
		{
			MethodName: "GetWhichErrs",
			Handler:    _God_GetWhichErrs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "serial/serial.proto",
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filename) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	if m.Line != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Line))
	}
	if m.Col != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Col))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if m.Options != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Options.Size()))
		n1, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Scope) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	return i, nil
}

func (m *Peers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Allocs) > 0 {
		for _, s := range m.Allocs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sends) > 0 {
		for _, s := range m.Sends {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Receives) > 0 {
		for _, s := range m.Receives {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Closes) > 0 {
		for _, s := range m.Closes {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ReferrersInitial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReferrersInitial) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjPos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.ObjPos)))
		i += copy(dAtA[i:], m.ObjPos)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *ReferrersPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReferrersPackage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Package) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Package)))
		i += copy(dAtA[i:], m.Package)
	}
	if len(m.Refs) > 0 {
		for _, msg := range m.Refs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Ref) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ref) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *Definition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Definition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjPos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.ObjPos)))
		i += copy(dAtA[i:], m.ObjPos)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *Callees) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Callees) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Callees) > 0 {
		for _, msg := range m.Callees {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Callee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Callee) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	return i, nil
}

func (m *Callers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Callers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Callers) > 0 {
		for _, msg := range m.Callers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Caller) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Caller) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Caller) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Caller)))
		i += copy(dAtA[i:], m.Caller)
	}
	return i, nil
}

func (m *CallStack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallStack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.Callers) > 0 {
		for _, msg := range m.Callers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FreeVars) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeVars) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FreeVar) > 0 {
		for _, msg := range m.FreeVar {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FreeVar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeVar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Ref)))
		i += copy(dAtA[i:], m.Ref)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *Implements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Implements) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.T != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.T.Size()))
		n2, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.AssignableTo) > 0 {
		for _, msg := range m.AssignableTo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AssignableFrom) > 0 {
		for _, msg := range m.AssignableFrom {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AssignableFromPtr) > 0 {
		for _, msg := range m.AssignableFromPtr {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Method != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Method.Size()))
		n3, err := m.Method.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.AssignableToMethod) > 0 {
		for _, msg := range m.AssignableToMethod {
			dAtA[i] = 0x32
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AssignableFromMethod) > 0 {
		for _, msg := range m.AssignableFromMethod {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AssignableFromPtrMethod) > 0 {
		for _, msg := range m.AssignableFromPtrMethod {
			dAtA[i] = 0x42
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImplementsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImplementsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	return i, nil
}

func (m *SyntaxNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyntaxNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Start != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *What) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *What) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Enclosing) > 0 {
		for _, msg := range m.Enclosing {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SrcDir) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.SrcDir)))
		i += copy(dAtA[i:], m.SrcDir)
	}
	if len(m.ImportPath) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.ImportPath)))
		i += copy(dAtA[i:], m.ImportPath)
	}
	if len(m.Object) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Object)))
		i += copy(dAtA[i:], m.Object)
	}
	if len(m.SameIDs) > 0 {
		for _, s := range m.SameIDs {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PointsToLabel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsToLabel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *PointsTo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointsTo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.NamePos) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.NamePos)))
		i += copy(dAtA[i:], m.NamePos)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DescribeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ObjPos) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.ObjPos)))
		i += copy(dAtA[i:], m.ObjPos)
	}
	return i, nil
}

func (m *DescribeMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeMethod) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	return i, nil
}

func (m *DescribeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.NamePos) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.NamePos)))
		i += copy(dAtA[i:], m.NamePos)
	}
	if len(m.NameDef) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.NameDef)))
		i += copy(dAtA[i:], m.NameDef)
	}
	if len(m.Methods) > 0 {
		for _, msg := range m.Methods {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DescribeMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeMember) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Methods) > 0 {
		for _, msg := range m.Methods {
			dAtA[i] = 0x32
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DescribePackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribePackage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Describe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Describe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Desc) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Pos)))
		i += copy(dAtA[i:], m.Pos)
	}
	if len(m.Detail) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Detail)))
		i += copy(dAtA[i:], m.Detail)
	}
	if m.Package != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Package.Size()))
		n4, err := m.Package.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Type != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Type.Size()))
		n5, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Value != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSerial(dAtA, i, uint64(m.Value.Size()))
		n6, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *WhichErrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WhichErrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrPos) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.ErrPos)))
		i += copy(dAtA[i:], m.ErrPos)
	}
	if len(m.Globals) > 0 {
		for _, s := range m.Globals {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Constants) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Constants)))
		i += copy(dAtA[i:], m.Constants)
	}
	if len(m.Types) > 0 {
		for _, msg := range m.Types {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSerial(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WhichErrsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WhichErrsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Position) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSerial(dAtA, i, uint64(len(m.Position)))
		i += copy(dAtA[i:], m.Position)
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Serial(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Serial(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSerial(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Line != 0 {
		n += 1 + sovSerial(uint64(m.Line))
	}
	if m.Col != 0 {
		n += 1 + sovSerial(uint64(m.Col))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Options) Size() (n int) {
	var l int
	_ = l
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Peers) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Allocs) > 0 {
		for _, s := range m.Allocs {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.Sends) > 0 {
		for _, s := range m.Sends {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.Receives) > 0 {
		for _, s := range m.Receives {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.Closes) > 0 {
		for _, s := range m.Closes {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *ReferrersInitial) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjPos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *ReferrersPackage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *Ref) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Definition) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjPos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Callees) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Callees) > 0 {
		for _, e := range m.Callees {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *Callee) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Callers) Size() (n int) {
	var l int
	_ = l
	if len(m.Callers) > 0 {
		for _, e := range m.Callers {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *Caller) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *CallStack) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Callers) > 0 {
		for _, e := range m.Callers {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *FreeVars) Size() (n int) {
	var l int
	_ = l
	if len(m.FreeVar) > 0 {
		for _, e := range m.FreeVar {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *FreeVar) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Implements) Size() (n int) {
	var l int
	_ = l
	if m.T != nil {
		l = m.T.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.AssignableTo) > 0 {
		for _, e := range m.AssignableTo {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.AssignableFrom) > 0 {
		for _, e := range m.AssignableFrom {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.AssignableFromPtr) > 0 {
		for _, e := range m.AssignableFromPtr {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.AssignableToMethod) > 0 {
		for _, e := range m.AssignableToMethod {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.AssignableFromMethod) > 0 {
		for _, e := range m.AssignableFromMethod {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.AssignableFromPtrMethod) > 0 {
		for _, e := range m.AssignableFromPtrMethod {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *ImplementsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *SyntaxNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovSerial(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovSerial(uint64(m.End))
	}
	return n
}

func (m *What) Size() (n int) {
	var l int
	_ = l
	if len(m.Enclosing) > 0 {
		for _, e := range m.Enclosing {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	l = len(m.SrcDir)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.ImportPath)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Object)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.SameIDs) > 0 {
		for _, s := range m.SameIDs {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *PointsToLabel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *PointsTo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.NamePos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *DescribeValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.ObjPos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *DescribeMethod) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *DescribeType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.NamePos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.NameDef)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Methods) > 0 {
		for _, e := range m.Methods {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *DescribeMember) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Methods) > 0 {
		for _, e := range m.Methods {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *DescribePackage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *Describe) Size() (n int) {
	var l int
	_ = l
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Pos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Package != nil {
		l = m.Package.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *WhichErrs) Size() (n int) {
	var l int
	_ = l
	l = len(m.ErrPos)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Globals) > 0 {
		for _, s := range m.Globals {
			l = len(s)
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	l = len(m.Constants)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.Size()
			n += 1 + l + sovSerial(uint64(l))
		}
	}
	return n
}

func (m *WhichErrsType) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovSerial(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovSerial(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSerial(x uint64) (n int) {
	return sovSerial(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &Options{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocs = append(m.Allocs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sends", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sends = append(m.Sends, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receives", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receives = append(m.Receives, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Closes = append(m.Closes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReferrersInitial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReferrersInitial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReferrersInitial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReferrersPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReferrersPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReferrersPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, Ref{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ref) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ref: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ref: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Definition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Definition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Definition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Callees) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Callees: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Callees: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callees = append(m.Callees, &Callee{})
			if err := m.Callees[len(m.Callees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Callee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Callee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Callee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Callers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Callers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Callers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callers = append(m.Callers, &Caller{})
			if err := m.Callers[len(m.Callers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Caller) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Caller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Caller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallStack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallStack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallStack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callers = append(m.Callers, Caller{})
			if err := m.Callers[len(m.Callers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeVars) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeVars: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeVars: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeVar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FreeVar = append(m.FreeVar, &FreeVar{})
			if err := m.FreeVar[len(m.FreeVar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeVar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Implements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Implements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Implements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.T == nil {
				m.T = &ImplementsType{}
			}
			if err := m.T.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableTo = append(m.AssignableTo, ImplementsType{})
			if err := m.AssignableTo[len(m.AssignableTo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableFrom = append(m.AssignableFrom, ImplementsType{})
			if err := m.AssignableFrom[len(m.AssignableFrom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableFromPtr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableFromPtr = append(m.AssignableFromPtr, ImplementsType{})
			if err := m.AssignableFromPtr[len(m.AssignableFromPtr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &DescribeMethod{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableToMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableToMethod = append(m.AssignableToMethod, DescribeMethod{})
			if err := m.AssignableToMethod[len(m.AssignableToMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableFromMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableFromMethod = append(m.AssignableFromMethod, DescribeMethod{})
			if err := m.AssignableFromMethod[len(m.AssignableFromMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignableFromPtrMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignableFromPtrMethod = append(m.AssignableFromPtrMethod, DescribeMethod{})
			if err := m.AssignableFromPtrMethod[len(m.AssignableFromPtrMethod)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImplementsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImplementsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImplementsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyntaxNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyntaxNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyntaxNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *What) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: What: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: What: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enclosing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enclosing = append(m.Enclosing, SyntaxNode{})
			if err := m.Enclosing[len(m.Enclosing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Object = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SameIDs = append(m.SameIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsToLabel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsToLabel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsToLabel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointsTo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointsTo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointsTo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, PointsToLabel{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamePos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameDef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameDef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, DescribeMethod{})
			if err := m.Methods[len(m.Methods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Methods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Methods = append(m.Methods, DescribeMethod{})
			if err := m.Methods[len(m.Methods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribePackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribePackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribePackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &DescribeMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Describe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Describe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Describe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Package == nil {
				m.Package = &DescribePackage{}
			}
			if err := m.Package.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &DescribeType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DescribeValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WhichErrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WhichErrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WhichErrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Globals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Globals = append(m.Globals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constants", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constants = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, WhichErrsType{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WhichErrsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WhichErrsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WhichErrsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSerial
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSerial(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSerial
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSerial(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSerial
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSerial
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSerial
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSerial
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSerial(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSerial = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSerial   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("serial/serial.proto", fileDescriptorSerial) }

var fileDescriptorSerial = []byte{
	// 1368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xf6, 0x76, 0xfd, 0x7b, 0x9c, 0xbf, 0x0e, 0x69, 0x6a, 0x45, 0x28, 0x8d, 0x46, 0x20, 0x19,
	0x45, 0x4d, 0x69, 0xa2, 0x16, 0x2e, 0x10, 0xd0, 0xd6, 0x69, 0xd4, 0xd2, 0x1f, 0xb3, 0x09, 0xa9,
	0xb8, 0x5c, 0x6f, 0x8e, 0x9d, 0xa5, 0xeb, 0x1d, 0x33, 0x3b, 0x41, 0xed, 0x23, 0x70, 0x03, 0x3c,
	0x08, 0x42, 0x3c, 0x01, 0xd7, 0xbd, 0x44, 0x3c, 0x00, 0x82, 0xf2, 0x22, 0x68, 0x7e, 0x77, 0xd7,
	0x76, 0xd2, 0xe4, 0x6a, 0xe7, 0xcc, 0x39, 0xdf, 0xf9, 0x9b, 0x33, 0x67, 0xce, 0xc2, 0x7b, 0x19,
	0xf2, 0x38, 0x4c, 0x6e, 0xe9, 0xcf, 0xf6, 0x84, 0x33, 0xc1, 0x48, 0x5d, 0x53, 0xeb, 0x37, 0x47,
	0xb1, 0x38, 0x39, 0x1d, 0x6c, 0x47, 0x6c, 0x7c, 0x6b, 0xc4, 0x46, 0xec, 0x96, 0x62, 0x0f, 0x4e,
	0x87, 0x8a, 0x52, 0x84, 0x5a, 0x69, 0x18, 0xfd, 0xd1, 0x83, 0xe6, 0x13, 0x16, 0x85, 0x22, 0x66,
	0x29, 0x59, 0x87, 0xe6, 0x30, 0x4e, 0x30, 0x0d, 0xc7, 0xd8, 0xf1, 0x36, 0xbd, 0x6e, 0x2b, 0x70,
	0x34, 0x21, 0x50, 0x4d, 0xe2, 0x14, 0x3b, 0x57, 0x36, 0xbd, 0xae, 0x1f, 0xa8, 0x35, 0x59, 0x01,
	0x3f, 0x62, 0x49, 0xc7, 0x57, 0x5b, 0x72, 0x29, 0x77, 0x26, 0x2c, 0xeb, 0x54, 0x15, 0x58, 0x2e,
	0xc9, 0x47, 0xd0, 0x60, 0x13, 0xa9, 0x3d, 0xeb, 0xd4, 0x36, 0xbd, 0x6e, 0x7b, 0x67, 0x79, 0xdb,
	0xf8, 0xfd, 0x5c, 0x6f, 0x07, 0x96, 0x4f, 0x6f, 0x40, 0xc3, 0xec, 0x91, 0x55, 0xa8, 0x1d, 0x44,
	0x6c, 0x62, 0xdd, 0xd0, 0x04, 0xfd, 0xd9, 0x83, 0x5a, 0x1f, 0x91, 0x67, 0xd2, 0x4e, 0x9f, 0x65,
	0x86, 0x2b, 0x97, 0xd2, 0xbf, 0xc3, 0xd7, 0x13, 0xed, 0x5f, 0x2b, 0x50, 0x6b, 0xb2, 0x06, 0xf5,
	0x7b, 0x49, 0xc2, 0xa2, 0xac, 0xe3, 0x6f, 0xfa, 0xdd, 0x56, 0x60, 0x28, 0xa5, 0x1d, 0xd3, 0x63,
	0xe9, 0xa7, 0xaf, 0xb4, 0x4b, 0x42, 0x46, 0x1f, 0x60, 0x84, 0xf1, 0x0f, 0x28, 0x5d, 0x95, 0x0c,
	0x47, 0x4b, 0x4d, 0x0f, 0x12, 0x96, 0x61, 0xd6, 0xa9, 0x6b, 0x4d, 0x9a, 0xa2, 0x9f, 0xc3, 0x4a,
	0x80, 0x43, 0xe4, 0x1c, 0x79, 0xf6, 0x28, 0x8d, 0x45, 0x1c, 0x26, 0x52, 0xf6, 0xf9, 0xe0, 0xbb,
	0xdc, 0x3d, 0x43, 0x49, 0x0f, 0x7b, 0x98, 0x45, 0xd6, 0x43, 0xb9, 0xa6, 0x07, 0x05, 0x7c, 0x3f,
	0x8c, 0x5e, 0x86, 0x23, 0x24, 0x1d, 0x68, 0x98, 0xa5, 0x51, 0x60, 0x49, 0xf2, 0x21, 0x54, 0x03,
	0x1c, 0x66, 0x9d, 0x2b, 0x9b, 0x7e, 0xb7, 0xbd, 0xd3, 0xb6, 0x89, 0x0c, 0x70, 0x78, 0xbf, 0xfa,
	0xe6, 0xef, 0x1b, 0x95, 0x40, 0xb1, 0xe9, 0x16, 0xf8, 0x01, 0x0e, 0xcf, 0xc8, 0x11, 0xbe, 0x12,
	0x2e, 0x47, 0xf8, 0x4a, 0xd0, 0x4f, 0x01, 0x7a, 0x38, 0x8c, 0xa5, 0xef, 0x2c, 0xbd, 0x94, 0xef,
	0xdf, 0x42, 0xe3, 0x41, 0x98, 0x24, 0x88, 0x67, 0x1c, 0xc7, 0x34, 0x80, 0x74, 0x1d, 0x40, 0x9d,
	0x47, 0x7b, 0x67, 0xc9, 0x46, 0xa0, 0xb7, 0x03, 0xcb, 0xa6, 0xdb, 0x50, 0xd7, 0x4b, 0xa9, 0xe7,
	0x59, 0x5e, 0x8e, 0x6a, 0x6d, 0xad, 0x5d, 0x71, 0xd6, 0xe8, 0xae, 0xd1, 0xcc, 0x33, 0x67, 0x84,
	0x4b, 0x77, 0x66, 0x8d, 0xf0, 0xc0, 0xb2, 0xe9, 0x43, 0x63, 0x84, 0x5f, 0xd0, 0xfd, 0x35, 0x2b,
	0xaf, 0x0a, 0x5e, 0xd6, 0x80, 0xa2, 0x28, 0x42, 0x4b, 0xae, 0x0e, 0x44, 0x18, 0xbd, 0x9c, 0xa3,
	0x6a, 0x0d, 0xea, 0x87, 0x21, 0x1f, 0xa1, 0x4d, 0xbb, 0xa1, 0xc8, 0x76, 0xee, 0xe8, 0xbc, 0x6c,
	0x70, 0x73, 0xa4, 0xce, 0xdd, 0x3b, 0xd0, 0x7c, 0xc8, 0x11, 0x8f, 0x42, 0xae, 0x2e, 0x95, 0x59,
	0x9b, 0x20, 0xdd, 0xa5, 0x32, 0xdb, 0x81, 0xe5, 0xd3, 0x6f, 0x9c, 0xe8, 0xfc, 0x30, 0xbf, 0x8a,
	0xd3, 0x63, 0x1b, 0xa6, 0x5c, 0x4b, 0xa9, 0x00, 0x87, 0x26, 0x46, 0x55, 0x48, 0xf6, 0x6a, 0x55,
	0xf3, 0xab, 0x45, 0x7f, 0xab, 0x02, 0x3c, 0x1a, 0x4f, 0x12, 0x1c, 0x63, 0x2a, 0x32, 0xf2, 0x01,
	0x78, 0x87, 0x4a, 0x71, 0x7b, 0x67, 0xcd, 0xba, 0x92, 0xb3, 0x25, 0x22, 0xf0, 0x0e, 0xc9, 0x97,
	0xb0, 0x70, 0x2f, 0xcb, 0xe2, 0x51, 0x1a, 0x0e, 0x12, 0x3c, 0x64, 0xa6, 0x8e, 0xcf, 0x00, 0x98,
	0xf8, 0x4b, 0x08, 0xd2, 0x83, 0xa5, 0x9c, 0x7e, 0xc8, 0xd9, 0xd8, 0xe4, 0xee, 0x7c, 0x1d, 0x53,
	0x18, 0xf2, 0x18, 0xae, 0x96, 0x77, 0xfa, 0x82, 0xab, 0x5e, 0xf0, 0x2e, 0x45, 0xb3, 0x30, 0xb2,
	0x0d, 0xf5, 0xa7, 0x28, 0x4e, 0xd8, 0xb1, 0x69, 0x6f, 0x4e, 0x81, 0xac, 0x19, 0x1e, 0x0f, 0x50,
	0x73, 0x03, 0x23, 0x45, 0x9e, 0x00, 0x29, 0x46, 0x64, 0xb0, 0xf5, 0xb2, 0xf1, 0x32, 0xd6, 0x18,
	0x9f, 0x83, 0x23, 0x7d, 0x58, 0x2d, 0xbb, 0x64, 0xf4, 0x35, 0x2e, 0xa0, 0x6f, 0x2e, 0x92, 0x1c,
	0xc1, 0xf5, 0x99, 0x20, 0x8d, 0xd2, 0xe6, 0x05, 0x94, 0x9e, 0x05, 0xa6, 0x8f, 0x61, 0xa9, 0x9c,
	0xd2, 0x8b, 0x5d, 0x6d, 0x57, 0xa2, 0x7e, 0x5e, 0xa2, 0xf4, 0x08, 0xe0, 0xe0, 0x75, 0x2a, 0xc2,
	0x57, 0xcf, 0xd8, 0x31, 0x92, 0x4d, 0x68, 0x6b, 0x57, 0xd4, 0xdb, 0x61, 0xd4, 0x15, 0xb7, 0x54,
	0xbf, 0x17, 0x21, 0xd7, 0x37, 0xb0, 0x16, 0x68, 0x42, 0xda, 0xda, 0x33, 0x8a, 0x6b, 0x81, 0x5c,
	0xd2, 0x3f, 0x3c, 0xa8, 0xbe, 0x38, 0x09, 0x05, 0xb9, 0x0b, 0xad, 0xbd, 0x34, 0x4a, 0x58, 0x16,
	0xa7, 0x23, 0x73, 0xc3, 0x88, 0x0d, 0x3b, 0xb7, 0x6c, 0x42, 0xce, 0x45, 0xa5, 0xa1, 0xa7, 0xec,
	0x18, 0x75, 0x87, 0x6e, 0x05, 0x9a, 0x90, 0x1d, 0xe0, 0x80, 0x47, 0xbd, 0xd8, 0x35, 0x0e, 0x4d,
	0x91, 0x0d, 0x75, 0x85, 0x18, 0x17, 0xfd, 0x50, 0x9c, 0x98, 0xdb, 0x55, 0xd8, 0x31, 0xcd, 0x18,
	0x23, 0xa1, 0x4a, 0x4b, 0x37, 0x63, 0x8c, 0x84, 0x7c, 0x20, 0x0e, 0xc2, 0x31, 0x3e, 0xea, 0xd9,
	0xd7, 0xc8, 0x92, 0xf4, 0x0e, 0x2c, 0xf6, 0x59, 0x2c, 0x13, 0xcc, 0x9e, 0x84, 0x03, 0x4c, 0x2e,
	0xd6, 0xd9, 0xe8, 0x18, 0x9a, 0x16, 0xe6, 0x2e, 0xbb, 0x57, 0x78, 0x47, 0x3b, 0xd0, 0x90, 0xa7,
	0x93, 0x9f, 0x8c, 0x25, 0xc9, 0x2e, 0xd4, 0x95, 0x21, 0xdb, 0xc3, 0xae, 0xd9, 0x2c, 0x95, 0xdc,
	0x30, 0x89, 0x32, 0xa2, 0xf4, 0x6b, 0x58, 0xb4, 0xb5, 0x73, 0x14, 0x26, 0xa7, 0x38, 0xd7, 0xe6,
	0x2a, 0xd4, 0x14, 0xd3, 0x58, 0xd4, 0x44, 0xe1, 0x7d, 0xf2, 0x8b, 0xef, 0x13, 0xbd, 0x0b, 0x4b,
	0xe5, 0x72, 0x3c, 0xaf, 0xba, 0xfc, 0xfc, 0xe1, 0xf8, 0xc9, 0x83, 0x05, 0x0b, 0xb4, 0x45, 0x79,
	0x89, 0xf0, 0x0d, 0xa7, 0xe7, 0xfa, 0xa5, 0x25, 0xc9, 0x5d, 0x68, 0x68, 0x47, 0xb2, 0xe9, 0xc6,
	0x32, 0xf7, 0xda, 0x58, 0x61, 0xfa, 0xab, 0x57, 0x8c, 0x64, 0x3c, 0x40, 0x3e, 0x37, 0x92, 0x79,
	0xd3, 0x8e, 0xcb, 0x98, 0x5f, 0xcc, 0x98, 0x89, 0xb9, 0x3a, 0x7b, 0xa3, 0x6a, 0x85, 0xa6, 0x5f,
	0x70, 0xb7, 0x7e, 0x19, 0x77, 0x5f, 0xc0, 0xb2, 0x15, 0xb0, 0x43, 0x0a, 0x81, 0xaa, 0xaa, 0x67,
	0xe3, 0xae, 0xaa, 0xe4, 0x8f, 0xa5, 0x7a, 0x19, 0x4c, 0x36, 0xdd, 0xf3, 0xcb, 0xb1, 0x06, 0x56,
	0x8c, 0xfe, 0xe5, 0x41, 0xd3, 0xf2, 0x5c, 0xcd, 0x7a, 0x85, 0xd7, 0x78, 0xb6, 0x53, 0xac, 0x41,
	0xbd, 0x87, 0x22, 0x8c, 0x13, 0x5b, 0x1b, 0x9a, 0x22, 0xb7, 0xf3, 0x79, 0xaa, 0xaa, 0x5a, 0xf4,
	0xf5, 0x69, 0xe3, 0x86, 0x9d, 0x0f, 0x5a, 0x5d, 0x93, 0x5e, 0xdd, 0xd2, 0x57, 0xa7, 0xe5, 0xd5,
	0x7b, 0xa6, 0x93, 0xbe, 0x65, 0x93, 0x5e, 0x57, 0xa2, 0xd7, 0xa6, 0x45, 0x15, 0xd3, 0x9c, 0x85,
	0xac, 0xb6, 0xd6, 0x8b, 0x93, 0x38, 0x3a, 0xd9, 0xe3, 0x5c, 0xf9, 0xbb, 0xc7, 0x79, 0x61, 0xd6,
	0xd2, 0x94, 0x2c, 0xaa, 0xfd, 0x84, 0x0d, 0xc2, 0xc4, 0xb6, 0x11, 0x4b, 0x92, 0xf7, 0xa1, 0xf5,
	0x80, 0xa5, 0x99, 0x08, 0x53, 0x61, 0xab, 0x38, 0xdf, 0x20, 0xb7, 0xa1, 0x26, 0x5d, 0xb2, 0x05,
	0xe7, 0x5c, 0x71, 0x16, 0x0b, 0x0f, 0x99, 0x96, 0xa4, 0x5f, 0xc0, 0x62, 0x89, 0x3b, 0xb7, 0xfc,
	0xd7, 0x65, 0x77, 0xc8, 0xd4, 0x7c, 0x68, 0xd2, 0xed, 0x68, 0xda, 0x82, 0x46, 0x80, 0xdf, 0x9f,
	0x62, 0x26, 0x28, 0xc8, 0xf1, 0x39, 0x9b, 0xb0, 0x34, 0xc3, 0x9d, 0xdf, 0x6b, 0xe0, 0xef, 0xb3,
	0x63, 0xb2, 0x05, 0xd5, 0xbe, 0xec, 0x8b, 0xcb, 0xf9, 0xa8, 0xaa, 0x84, 0xd7, 0x57, 0xf2, 0x0d,
	0x0d, 0xa1, 0x15, 0x72, 0x1b, 0x60, 0x1f, 0x85, 0x1b, 0x29, 0xad, 0x84, 0xfd, 0x3b, 0x59, 0x5f,
	0x2e, 0x4f, 0x8b, 0x59, 0x19, 0xc2, 0xdf, 0x0d, 0xe1, 0x12, 0x72, 0x07, 0x16, 0x0c, 0xc4, 0x0c,
	0x6c, 0x33, 0xa0, 0xab, 0x45, 0x90, 0x12, 0xa2, 0x15, 0xf2, 0x09, 0x2c, 0xee, 0xa3, 0x28, 0x4c,
	0xca, 0xb3, 0x38, 0x92, 0x9f, 0xbd, 0x95, 0xa2, 0x15, 0xb2, 0x0b, 0x6d, 0x05, 0x34, 0xa5, 0x3c,
	0x0b, 0x5b, 0x99, 0x2e, 0x19, 0x5a, 0x21, 0x3b, 0x2a, 0x2e, 0x37, 0xb7, 0x9d, 0x8d, 0xb1, 0x13,
	0xa1, 0xf3, 0xb0, 0x30, 0x93, 0x9d, 0xe3, 0x61, 0x2e, 0x45, 0x2b, 0xe4, 0x26, 0x34, 0xf7, 0x51,
	0x98, 0xff, 0xaa, 0x19, 0xcc, 0xa2, 0xeb, 0xe8, 0xa8, 0x13, 0xa8, 0x03, 0x72, 0xef, 0xc5, 0x39,
	0xce, 0x59, 0x19, 0x5a, 0x21, 0x9f, 0xa9, 0xac, 0xbb, 0x5f, 0x9d, 0x39, 0xa8, 0x4e, 0xe1, 0x6f,
	0xa6, 0xf4, 0x3f, 0x44, 0x2b, 0x64, 0x0b, 0x1a, 0xfb, 0x28, 0xd4, 0xcb, 0x3c, 0x0b, 0x5c, 0xc8,
	0xeb, 0x3c, 0x14, 0xee, 0x80, 0xf3, 0x6b, 0x76, 0xce, 0x01, 0x3b, 0x21, 0x5a, 0xb9, 0xbf, 0xfa,
	0xe6, 0xdf, 0x8d, 0xca, 0x9b, 0xb7, 0x1b, 0xde, 0x9f, 0x6f, 0x37, 0xbc, 0x7f, 0xde, 0x6e, 0x78,
	0xbf, 0xfc, 0xb7, 0x51, 0x19, 0xd4, 0xd5, 0x5f, 0xf2, 0xee, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x94, 0x51, 0x40, 0xc8, 0x73, 0x0f, 0x00, 0x00,
}
